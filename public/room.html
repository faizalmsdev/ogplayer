<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Room Sync Music Player</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
        }

        .room-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .room-section {
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e0e0e0;
        }

        .room-section h3 {
            margin-bottom: 15px;
            color: #5a6c7d;
            font-size: 1.2rem;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .btn-secondary {
            background: #f8f9fa;
            color: #333;
            border: 2px solid #ddd;
        }

        .btn-secondary:hover {
            background: #e9ecef;
            border-color: #adb5bd;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .status.connected {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.disconnected {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .player-section {
            margin-top: 20px;
        }

        .player-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toggle-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #555;
            user-select: none;
        }

        .toggle-label input[type="checkbox"] {
            display: none;
        }

        .toggle-slider {
            position: relative;
            width: 44px;
            height: 24px;
            background: #ccc;
            border-radius: 24px;
            transition: background 0.3s;
        }

        .toggle-slider:before {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            top: 3px;
            left: 3px;
            transition: transform 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .toggle-label input[type="checkbox"]:checked + .toggle-slider {
            background: linear-gradient(45deg, #667eea, #764ba2);
        }

        .toggle-label input[type="checkbox"]:checked + .toggle-slider:before {
            transform: translateX(20px);
        }

        .ntp-info {
            background: #e7f3ff;
            border: 1px solid #b3d9ff;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .ntp-info h4 {
            margin-bottom: 10px;
            color: #0066cc;
        }

        .ntp-info .time-display {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            background: white;
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
        }

        .audio-player {
            width: 100%;
            margin: 20px 0;
            border-radius: 8px;
        }

        /* Hide audio controls for listeners */
        .audio-player:not(.admin-controls)::-webkit-media-controls-panel {
            display: none !important;
        }

        .audio-player:not(.admin-controls)::-webkit-media-controls {
            display: none !important;
        }

        .audio-player:not(.admin-controls)::-moz-media-controls {
            display: none !important;
        }

        .audio-player:not(.admin-controls) {
            pointer-events: none;
        }

        /* Show controls for admins */
        .audio-player.admin-controls {
            pointer-events: auto;
        }

        .listener-notice {
            background: #e7f3ff;
            border: 1px solid #b3d9ff;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            text-align: center;
            color: #0066cc;
            font-size: 0.9rem;
        }

        .song-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .playlist-section {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
        }

        .song-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background 0.2s;
        }

        .song-item:hover {
            background: #f0f0f0;
        }

        .song-item:last-child {
            border-bottom: none;
        }

        .log {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin-top: 20px;
        }

        .queue-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .queue-modal.show {
            display: flex;
        }

        .queue-content {
            background: white;
            border-radius: 15px;
            padding: 25px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .queue-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #eee;
            padding-bottom: 15px;
        }

        .queue-header h3 {
            margin: 0;
            color: #333;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            background: #f0f0f0;
        }

        .current-song {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .current-song h4 {
            margin: 0 0 10px 0;
            font-size: 1.1rem;
        }

        .queue-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .queue-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            margin-bottom: 10px;
            background: #f9f9f9;
            transition: background 0.2s;
        }

        .queue-item:hover {
            background: #f0f0f0;
        }

        .queue-item.current {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border-color: #667eea;
        }

        .queue-item-info {
            flex: 1;
        }

        .queue-item-info strong {
            display: block;
            font-size: 1rem;
        }

        .queue-item-info small {
            color: #666;
            font-size: 0.9rem;
        }

        .queue-item.current .queue-item-info small {
            color: rgba(255, 255, 255, 0.8);
        }

        .queue-item-actions {
            display: flex;
            gap: 10px;
        }

        .queue-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            font-size: 16px;
            transition: background 0.2s;
        }

        .queue-btn:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        .queue-item.current .queue-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .queue-empty {
            text-align: center;
            color: #666;
            padding: 40px;
            font-style: italic;
        }

        .queue-section {
            max-height: 250px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            margin-top: 15px;
            background: #f8f9fa;
        }

        .visible-queue-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            border-bottom: 1px solid #eee;
            background: white;
            border-radius: 6px;
            margin-bottom: 5px;
        }

        .visible-queue-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .visible-queue-item.current {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: 1px solid #667eea;
        }

        .visible-queue-item-info {
            flex: 1;
            font-size: 0.9rem;
        }

        .visible-queue-item-info strong {
            display: block;
            font-size: 0.95rem;
        }

        .visible-queue-item-info small {
            color: #666;
            font-size: 0.8rem;
        }

        .visible-queue-item.current .visible-queue-item-info small {
            color: rgba(255, 255, 255, 0.8);
        }

        .queue-position {
            font-weight: bold;
            margin-right: 10px;
            min-width: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéµ Room Sync Music Player</h1>
            <p>Synchronized music playback with NTP timing</p>
        </div>

        <!-- Connection Status -->
        <div id="connectionStatus" class="status disconnected">
            ‚ùå Disconnected from server
        </div>

        <!-- Room Controls -->
        <div class="card">
            <div class="room-controls">
                <div class="room-section">
                    <h3>üö™ Create Room</h3>
                    <div class="form-group">
                        <label for="createRoomName">Room Name</label>
                        <input type="text" id="createRoomName" placeholder="Enter room name">
                    </div>
                    <button class="btn btn-primary" onclick="createRoom()">Create & Join as Admin</button>
                </div>

                <div class="room-section">
                    <h3>üîó Join Room</h3>
                    <div class="form-group">
                        <label for="joinRoomName">Room Name</label>
                        <input type="text" id="joinRoomName" placeholder="Enter room name">
                    </div>
                    <button class="btn btn-secondary" onclick="joinRoom()">Join as Listener</button>
                </div>
            </div>
        </div>

        <!-- NTP Synchronization Info -->
        <div class="card">
            <div class="ntp-info">
                <h4>‚è∞ Time Synchronization</h4>
                <div class="time-display">
                    <div>Server Time: <span id="serverTime">--:--:--</span></div>
                    <div>Local Time: <span id="localTime">--:--:--</span></div>
                    <div>Offset: <span id="timeOffset">0ms</span></div>
                    <div>Last Sync: <span id="lastSync">Never</span></div>
                </div>
            </div>
        </div>

        <!-- Player Section -->
        <div class="card">
            <div class="player-section">
                <h3>üé∂ Music Player</h3>
                
                <div class="player-controls">
                    <button class="btn btn-primary" onclick="loadPlaylist()" id="loadPlaylistBtn">Load Playlist</button>
                    <button class="btn btn-primary" onclick="shufflePlay()" id="shuffleBtn" disabled>Shuffle Play</button>
                    <button class="btn btn-secondary" onclick="skipToNext()" id="nextBtn" disabled>‚è≠Ô∏è Next</button>
                    <button class="btn btn-secondary" onclick="showQueueModal()" id="showQueueBtn" disabled>Show Queue</button>
                    <button class="btn btn-secondary" onclick="syncTime()" id="syncBtn">Sync Time</button>
                    <div class="control-toggle" id="controlToggle" style="display: none;">
                        <label class="toggle-label">
                            <input type="checkbox" id="anyoneCanControl" onchange="toggleAnyoneCanControl()">
                            <span class="toggle-slider"></span>
                            Allow Anyone to Control
                        </label>
                    </div>
                    <select id="playlistSelect">
                        <option value="">Select Playlist...</option>
                    </select>
                </div>

                <div class="song-info" id="currentSongInfo" style="display:none;">
                    <strong>Now Playing:</strong>
                    <div id="songDetails">No song selected</div>
                </div>

                <audio id="audioPlayer" class="audio-player">
                    Your browser does not support the audio element.
                </audio>
                
                <div id="listenerMessage" class="listener-notice" style="display: none;">
                    <p>üéß You are listening as a guest. Only the room admin can control playback.</p>
                    <p id="controlModeMessage" style="display: none;">üéõÔ∏è Anyone can control mode is enabled - you can control playback!</p>
                </div>

                <div class="playlist-section" id="playlistSongs" style="display:none;">
                    <h4>Playlist Songs:</h4>
                    <div id="songsList"></div>
                </div>

                <!-- Visible Queue Section -->
                <div class="queue-section" id="visibleQueueSection">
                    <h4>üéµ Current Queue:</h4>
                    <div id="visibleQueueList">
                        <div class="queue-empty">Queue is empty. Add songs to get started!</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Activity Log -->
        <div class="card">
            <h3>üìã Activity Log</h3>
            <div id="activityLog" class="log">
                <div>üîå Connecting to server...</div>
            </div>
        </div>
    </div>

    <!-- Queue Modal -->
    <div id="queueModal" class="queue-modal">
        <div class="queue-content">
            <div class="queue-header">
                <h3>üéµ Music Queue</h3>
                <button class="close-btn" onclick="closeQueueModal()">√ó</button>
            </div>
            
            <div id="currentSongDisplay" class="current-song" style="display: none;">
                <h4>Now Playing</h4>
                <div id="currentSongDetails">No song playing</div>
            </div>
            
            <div class="queue-list" id="queueList">
                <div class="queue-empty">Queue is empty. Add songs to get started!</div>
            </div>
            
            <div class="queue-controls">
                <button class="btn btn-secondary" onclick="clearQueue()">Clear Queue</button>
                <button class="btn btn-primary" onclick="closeQueueModal()">Close</button>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let socket = null;
        let currentRoom = null;
        let isAdmin = false;
        let timeOffset = 0;
        let playlists = {};
        let currentPlaylist = [];
        let ntpSyncInterval = null;
        let isSeeking = false; // Flag to prevent seek loops
        let anyoneCanControl = false; // Flag for anyone can control mode

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            initializeSocket();
            updateTimeDisplay();
            loadPlaylists();
            
            // Update time display every second
            setInterval(updateTimeDisplay, 1000);
            
            // Sync time every 30 seconds
            ntpSyncInterval = setInterval(syncTime, 30000);
        });

        function initializeSocket() {
            // Connect to your server (change URL as needed)
            socket = io('http://localhost:3000');

            socket.on('connect', function() {
                log('‚úÖ Connected to server');
                updateConnectionStatus(true);
                syncTime(); // Initial time sync
                
                // Only update controls if user hasn't joined a room yet
                if (!currentRoom) {
                    updateUserControls();
                }
                
                // Set up audio player event listeners
                const audio = document.getElementById('audioPlayer');
                audio.addEventListener('ended', function() {
                    if (currentRoom) {
                        socket.emit('song_ended', { room: currentRoom });
                        log('üîö Song ended, requesting next song');
                    }
                });

                // Add seek event listener for seeking (admin or anyone if enabled)
                audio.addEventListener('seeked', function() {
                    if (currentRoom && (isAdmin || anyoneCanControl) && !isSeeking) {
                        const seekTime = audio.currentTime;
                        socket.emit('seek_song', { 
                            room: currentRoom, 
                            seekTime: seekTime 
                        });
                        log(`‚è© ${isAdmin ? 'Admin' : 'User'} seeked to ${seekTime.toFixed(2)}s`);
                    } else if (!isAdmin && !anyoneCanControl && !isSeeking) {
                        // If a listener somehow triggered seek in restricted mode, revert it
                        log('üö´ Seek blocked for listener - reverting to synced position');
                    }
                });
            });

            socket.on('disconnect', function() {
                log('‚ùå Disconnected from server');
                updateConnectionStatus(false);
                currentRoom = null;
            });

            socket.on('play_song', function(data) {
                handlePlaySongEvent(data);
            });

            socket.on('queue_update', function(data) {
                updateQueueDisplay(data.queue, data.currentSong);
            });

            socket.on('seek_song', function(data) {
                log(`‚è© Received seek command: ${data.seekTime.toFixed(2)}s`);
                const audio = document.getElementById('audioPlayer');
                isSeeking = true;
                audio.currentTime = data.seekTime;
                // Reset the flag after a short delay to allow the seek to complete
                setTimeout(() => { isSeeking = false; }, 100);
            });

            socket.on('admin_status', function(data) {
                const wasAdmin = isAdmin;
                isAdmin = data.isAdmin;
                
                if (wasAdmin !== isAdmin) {
                    log(`${isAdmin ? 'üëë' : 'üéß'} Admin status updated: ${isAdmin ? 'Admin' : 'Listener'}`);
                    updateUserControls();
                }
            });

            socket.on('toggle_anyone_can_control', function(data) {
                anyoneCanControl = data.enabled;
                const checkbox = document.getElementById('anyoneCanControl');
                if (checkbox) {
                    checkbox.checked = anyoneCanControl;
                }
                updateUserControls();
                log(`${data.enabled ? 'üîì' : 'üîí'} Anyone can control mode: ${data.enabled ? 'ENABLED' : 'DISABLED'}`);
            });

            // Handle late joiner sync
            socket.on('sync_to_current', function(data) {
                log(`üîÑ Syncing to current song: ${data.url}`);
                const audio = document.getElementById('audioPlayer');
                audio.src = data.url;
                // Seek to the correct position
                isSeeking = true;
                audio.currentTime = data.seekTo || 0;
                audio.play().then(() => {
                    log(`‚ñ∂Ô∏è Synced playback at ${data.seekTo ? data.seekTo.toFixed(2) : 0}s`);
                    setTimeout(() => { isSeeking = false; }, 100);
                }).catch(err => {
                    log(`‚ùå Sync playback failed: ${err.message}`);
                    isSeeking = false;
                });
                // Update song info if available
                if (data.songInfo) {
                    updateSongInfo(data.songInfo);
                }
            });

            socket.on('error', function(error) {
                log(`‚ùå Socket error: ${error}`);
            });
        }

        // Extracted play_song logic for reuse
        function handlePlaySongEvent(data) {
            log(`üéµ Received play command: ${data.url}`);
            log(`‚è∞ Start at: ${data.startAt}ms from now`);
            const audio = document.getElementById('audioPlayer');
            audio.src = data.url;
            // Calculate exact start time using NTP synchronization
            const currentTime = Date.now() + timeOffset;
            const startTime = data.startAt;
            const delay = startTime - currentTime;
            if (delay > 0) {
                log(`‚è±Ô∏è Waiting ${delay}ms to start playback`);
                setTimeout(() => {
                    audio.play().then(() => {
                        log('‚ñ∂Ô∏è Playback started (synchronized)');
                    }).catch(err => {
                        log(`‚ùå Playback failed: ${err.message}`);
                    });
                }, delay);
            } else {
                // If we're late, start immediately but seek to correct position
                const seekTo = Math.abs(delay) / 1000;
                log(`‚è≠Ô∏è Starting late, seeking to ${seekTo}s`);
                isSeeking = true;
                audio.currentTime = seekTo;
                audio.play().then(() => {
                    log('‚ñ∂Ô∏è Playback started (late sync)');
                    setTimeout(() => { isSeeking = false; }, 100);
                }).catch(err => {
                    log(`‚ùå Playback failed: ${err.message}`);
                    isSeeking = false;
                });
            }
            // Update song info if available
            if (data.songInfo) {
                updateSongInfo(data.songInfo);
            }
        }

        function createRoom() {
            const roomName = document.getElementById('createRoomName').value.trim();
            if (!roomName) {
                alert('Please enter a room name');
                return;
            }

            currentRoom = roomName;
            // Request admin status - server will confirm
            socket.emit('join_room', { room: roomName, isAdmin: true });
            log(`üè† Creating and joining room: ${roomName}`);
            
            // Don't set admin status locally - wait for server confirmation
        }

        function joinRoom() {
            const roomName = document.getElementById('joinRoomName').value.trim();
            if (!roomName) {
                alert('Please enter a room name');
                return;
            }

            currentRoom = roomName;
            // Don't override admin status if already set
            if (!isAdmin) {
                isAdmin = false;
            }
            
            socket.emit('join_room', { room: roomName, isAdmin: isAdmin });
            log(`üîó Joined room: ${roomName} (${isAdmin ? 'Admin' : 'Listener'})`);
            
            // Update controls based on current status
            if (isAdmin) {
                enableAdminControls();
            } else {
                disableAdminControls();
            }
        }

        async function loadPlaylists() {
            try {
                const response = await fetch('/playlists');
                const data = await response.json();
                playlists = data;
                
                const select = document.getElementById('playlistSelect');
                select.innerHTML = '<option value="">Select Playlist...</option>';
                
                Object.values(data).forEach(playlist => {
                    const option = document.createElement('option');
                    option.value = playlist.id;
                    option.textContent = `${playlist.display_name} (${playlist.has_songs ? 'Ready' : 'Empty'})`;
                    select.appendChild(option);
                });
                
                log(`üìã Loaded ${Object.keys(data).length} playlists`);
            } catch (error) {
                log(`‚ùå Failed to load playlists: ${error.message}`);
            }
        }

        async function loadPlaylist() {
            const playlistId = document.getElementById('playlistSelect').value;
            if (!playlistId) {
                alert('Please select a playlist');
                return;
            }

            try {
                const response = await fetch(`/playlist/${playlistId}/songs?limit=50`);
                const data = await response.json();
                currentPlaylist = data.songs || [];
                
                displayPlaylistSongs(data);
                log(`üéµ Loaded playlist: ${data.display_name} (${currentPlaylist.length} songs)`);
                
            } catch (error) {
                log(`‚ùå Failed to load playlist: ${error.message}`);
            }
        }

        function displayPlaylistSongs(playlistData) {
            const songsContainer = document.getElementById('songsList');
            const playlistSection = document.getElementById('playlistSongs');
            
            songsContainer.innerHTML = '';
            
            if (currentPlaylist.length > 0) {
                currentPlaylist.forEach((song, index) => {
                    const songDiv = document.createElement('div');
                    songDiv.className = 'song-item';
                    songDiv.innerHTML = `
                        <strong>${song.track_name}</strong><br>
                        <small>${song.artists_string} ‚Ä¢ ${song.duration_formatted || 'Unknown duration'}</small>
                    `;
                    songDiv.onclick = () => selectSong(song, index);
                    songsContainer.appendChild(songDiv);
                });
                
                playlistSection.style.display = 'block';
            } else {
                playlistSection.style.display = 'none';
            }
        }

        function selectSong(song, index) {
            if (!isAdmin || !currentRoom) {
                alert('Only room admin can control playback');
                return;
            }

            addSongToQueue(song.github_url, song);
        }

        async function shufflePlay() {
            if (!isAdmin || !currentRoom) {
                alert('Only room admin can control playback');
                return;
            }

            const playlistId = document.getElementById('playlistSelect').value;
            
            try {
                const url = playlistId ? 
                    `/shuffle-play?playlist=${playlistId}` : 
                    '/shuffle-play';
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.current_song) {
                    addSongToQueue(data.current_song.github_url, data.current_song);
                    log(`üé≤ Added shuffle song to queue: ${data.current_song.track_name} by ${data.current_song.artists_string}`);
                } else {
                    log('‚ùå No songs available for shuffle');
                }
                
            } catch (error) {
                log(`‚ùå Shuffle failed: ${error.message}`);
            }
        }

        function addSongToQueue(url, songInfo) {
            if (!currentRoom || !isAdmin) {
                log('‚ùå Cannot add to queue: Not admin or not in room');
                return;
            }

            // Emit add to queue event
            socket.emit('add_to_queue', { 
                room: currentRoom, 
                url: url,
                songInfo: songInfo
            });

            log(`‚ûï Added to queue: ${songInfo.track_name}`);
        }

        function playSongInRoom(url, songInfo) {
            if (!currentRoom || !isAdmin) {
                log('‚ùå Cannot play: Not admin or not in room');
                return;
            }

            // Calculate start time (2 seconds from now) with NTP offset
            const startAt = Date.now() + timeOffset + 2000;
            
            // Emit to room
            socket.emit('play_song', { 
                room: currentRoom, 
                url: url,
                startAt: startAt,
                songInfo: songInfo
            });

            // Update song info display
            updateSongInfo(songInfo);
            
            log(`üéµ Broadcasting to room: ${songInfo.track_name}`);
            log(`‚è∞ Scheduled start: ${new Date(startAt).toLocaleTimeString()}`);
        }

        function removeFromQueue(index) {
            if (!currentRoom || !isAdmin) {
                log('‚ùå Cannot remove from queue: Not admin or not in room');
                return;
            }

            socket.emit('remove_from_queue', { 
                room: currentRoom, 
                index: index
            });

            log(`‚ûñ Removed song from queue at position ${index + 1}`);
        }

        function clearQueue() {
            if (!currentRoom || !isAdmin) {
                log('‚ùå Cannot clear queue: Not admin or not in room');
                return;
            }

            socket.emit('clear_queue', { 
                room: currentRoom
            });

            log('üóëÔ∏è Cleared queue');
        }

        function enableAdminControls() {
            const audioPlayer = document.getElementById('audioPlayer');
            const listenerMessage = document.getElementById('listenerMessage');
            const controlToggle = document.getElementById('controlToggle');
            
            // Enable admin buttons
            document.getElementById('shuffleBtn').disabled = false;
            document.getElementById('showQueueBtn').disabled = false;
            document.getElementById('nextBtn').disabled = false;
            
            // Show control toggle for admin
            controlToggle.style.display = 'flex';
            
            // Enable audio controls for admin
            audioPlayer.classList.add('admin-controls');
            audioPlayer.controls = true;
            
            // Hide listener message
            if (listenerMessage) {
                listenerMessage.style.display = 'none';
            }
            
            log('üëë Admin controls enabled');
        }

        function disableAdminControls() {
            const audioPlayer = document.getElementById('audioPlayer');
            const listenerMessage = document.getElementById('listenerMessage');
            const controlToggle = document.getElementById('controlToggle');
            
            // Disable admin buttons
            document.getElementById('shuffleBtn').disabled = true;
            document.getElementById('showQueueBtn').disabled = true;
            document.getElementById('nextBtn').disabled = true;
            
            // Hide control toggle for listener
            controlToggle.style.display = 'none';
            
            // Update controls based on anyoneCanControl setting
            updateUserControls();
            
            // Show listener message
            if (listenerMessage) {
                listenerMessage.style.display = 'block';
            }
            
            log('üéß Listener controls disabled');
        }

        function toggleAnyoneCanControl() {
            const checkbox = document.getElementById('anyoneCanControl');
            anyoneCanControl = checkbox.checked;
            
            // Send the setting to server
            if (currentRoom && isAdmin) {
                socket.emit('toggle_anyone_can_control', { 
                    room: currentRoom, 
                    enabled: anyoneCanControl 
                });
                
                log(`${anyoneCanControl ? 'üîì' : 'üîí'} Anyone can control: ${anyoneCanControl ? 'ENABLED' : 'DISABLED'}`);
            }
            
            // Update controls for all users
            updateUserControls();
        }

        function updateUserControls() {
            // Don't override admin status if already set
            if (isAdmin) {
                enableAdminControls();
                return;
            }
            
            const audioPlayer = document.getElementById('audioPlayer');
            const listenerMessage = document.getElementById('listenerMessage');
            const controlModeMessage = document.getElementById('controlModeMessage');
            const nextBtn = document.getElementById('nextBtn');
            
            if (anyoneCanControl) {
                // Anyone can control mode - enable controls for listeners
                audioPlayer.classList.add('admin-controls');
                audioPlayer.controls = true;
                nextBtn.disabled = false;
                if (listenerMessage) {
                    listenerMessage.style.display = 'block';
                    controlModeMessage.style.display = 'block';
                }
                log('üéõÔ∏è Anyone can control mode - controls enabled for listeners');
            } else {
                // Normal listener mode - disable controls
                audioPlayer.classList.remove('admin-controls');
                audioPlayer.controls = false;
                nextBtn.disabled = true;
                if (listenerMessage) {
                    listenerMessage.style.display = 'block';
                    controlModeMessage.style.display = 'none';
                }
            }
        }

        function showQueueModal() {
            document.getElementById('queueModal').classList.add('show');
        }

        function closeQueueModal() {
            document.getElementById('queueModal').classList.remove('show');
        }

        function updateQueueDisplay(queue, currentSong) {
            const queueList = document.getElementById('queueList');
            const visibleQueueList = document.getElementById('visibleQueueList');
            const visibleQueueSection = document.getElementById('visibleQueueSection');
            const currentSongDisplay = document.getElementById('currentSongDisplay');
            const currentSongDetails = document.getElementById('currentSongDetails');
            const nextBtn = document.getElementById('nextBtn');

            // Update current song display
            if (currentSong) {
                currentSongDetails.innerHTML = `
                    <strong>${currentSong.songInfo.track_name}</strong><br>
                    <small>by ${currentSong.songInfo.artists_string}</small>
                    ${currentSong.songInfo.album_name ? `<br><small>Album: ${currentSong.songInfo.album_name}</small>` : ''}
                `;
                currentSongDisplay.style.display = 'block';
            } else {
                currentSongDisplay.style.display = 'none';
            }

            // Update modal queue list
            if (queue && queue.length > 0) {
                queueList.innerHTML = '';
                queue.forEach((item, index) => {
                    const queueItem = document.createElement('div');
                    queueItem.className = 'queue-item';
                    queueItem.innerHTML = `
                        <div class="queue-item-info">
                            <strong>${item.songInfo.track_name}</strong>
                            <small>by ${item.songInfo.artists_string}</small>
                        </div>
                        <div class="queue-item-actions">
                            ${isAdmin ? `<button class="queue-btn" onclick="removeFromQueue(${index})" title="Remove from queue">‚ùå</button>` : ''}
                        </div>
                    `;
                    queueList.appendChild(queueItem);
                });
            } else {
                queueList.innerHTML = '<div class="queue-empty">Queue is empty. Add songs to get started!</div>';
            }

            // Update visible queue list
            if (queue && queue.length > 0) {
                visibleQueueList.innerHTML = '';
                queue.forEach((item, index) => {
                    const visibleQueueItem = document.createElement('div');
                    visibleQueueItem.className = 'visible-queue-item';
                    visibleQueueItem.innerHTML = `
                        <div class="queue-position">${index + 1}.</div>
                        <div class="visible-queue-item-info">
                            <strong>${item.songInfo.track_name}</strong>
                            <small>by ${item.songInfo.artists_string}</small>
                        </div>
                    `;
                    visibleQueueList.appendChild(visibleQueueItem);
                });
            } else {
                visibleQueueList.innerHTML = '<div class="queue-empty">Queue is empty. Add songs to get started!</div>';
            }

            // Enable/disable queue and next buttons based on whether there are songs
            const showQueueBtn = document.getElementById('showQueueBtn');
            showQueueBtn.disabled = !queue || queue.length === 0;
            nextBtn.disabled = !isAdmin || !queue || queue.length === 0;
        }

        function updateSongInfo(song) {
            const songInfoDiv = document.getElementById('currentSongInfo');
            const songDetails = document.getElementById('songDetails');
            
            if (song) {
                songDetails.innerHTML = `
                    <strong>${song.track_name}</strong><br>
                    <small>by ${song.artists_string}</small>
                    ${song.album_name ? `<br><small>Album: ${song.album_name}</small>` : ''}
                `;
                songInfoDiv.style.display = 'block';
            } else {
                songInfoDiv.style.display = 'none';
            }
        }

        async function syncTime() {
            try {
                const startTime = Date.now();
                const response = await fetch('/ping');
                const endTime = Date.now();
                const data = await response.json();
                
                // Simple NTP-like calculation
                const roundTripTime = endTime - startTime;
                const serverTime = new Date(data.timestamp).getTime();
                const networkDelay = roundTripTime / 2;
                const estimatedServerTime = serverTime + networkDelay;
                
                timeOffset = estimatedServerTime - Date.now();
                
                document.getElementById('timeOffset').textContent = `${Math.round(timeOffset)}ms`;
                document.getElementById('lastSync').textContent = new Date().toLocaleTimeString();
                
                log(`üïê Time synced: offset ${Math.round(timeOffset)}ms (RTT: ${roundTripTime}ms)`);
                
            } catch (error) {
                log(`‚ùå Time sync failed: ${error.message}`);
            }
        }

        function updateTimeDisplay() {
            const now = new Date();
            const serverTime = new Date(now.getTime() + timeOffset);
            
            document.getElementById('localTime').textContent = now.toLocaleTimeString();
            document.getElementById('serverTime').textContent = serverTime.toLocaleTimeString();
        }

        function updateConnectionStatus(connected) {
            const status = document.getElementById('connectionStatus');
            if (connected) {
                status.className = 'status connected';
                status.innerHTML = '‚úÖ Connected to server';
            } else {
                status.className = 'status disconnected';
                status.innerHTML = '‚ùå Disconnected from server';
            }
        }

        function log(message) {
            const logDiv = document.getElementById('activityLog');
            const time = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.innerHTML = `[${time}] ${message}`;
            logDiv.appendChild(logEntry);
            logDiv.scrollTop = logDiv.scrollHeight;
            
            // Keep only last 50 entries
            while (logDiv.children.length > 50) {
                logDiv.removeChild(logDiv.firstChild);
            }
        }

        // Handle page visibility for better sync
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden && socket && socket.connected) {
                syncTime(); // Re-sync when page becomes visible
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
            if (ntpSyncInterval) {
                clearInterval(ntpSyncInterval);
            }
        });
    </script>
</body>
</html>